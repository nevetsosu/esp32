# 'Bare metal' ESP32 application Makefile
# Use the xtensa-esp32-elf toolchain.
TOOLCHAIN = xtensa-esp32-elf-

CFLAGS_PLATFORM  = -mlongcalls -mtext-section-literals -fstrict-volatile-bitfields
ASFLAGS_PLATFORM = $(CFLAGS_PLATFORM)
LDFLAGS_PLATFORM = $(CFLAGS_PLATFORM)

###
# General project build
###
CC = $(TOOLCHAIN)gcc
LD = $(TOOLCHAIN)ld
OC = $(TOOLCHAIN)objcopy
OS = $(TOOLCHAIN)size
OD = $(TOOLCHAIN)objdump

# Includes
INC = -I./include/
# Linker script location.
LDSCRIPT = ./ld/bootloader.ld

# Set C flags.
CFLAGS += $(INC) -Wall -Werror -std=gnu11 -nostdlib $(CFLAGS_PLATFORM) $(COPT)
CFLAGS += -fno-strict-aliasing
CFLAGS += -fdata-sections -ffunction-sections
CFLAGS += -Os		# optimize for size
CFLAGS += -g		# include debugging information
# CFLAGS += -O0

# Set LD flags
LDFLAGS += -nostdlib -T$(LDSCRIPT) -Wl,-Map=$@.map -Wl,--cref -Wl,--gc-sections
LDFLAGS += $(LDFLAGS_PLATFORM)
LDFLAGS += -lm -lc -lgcc

# Set AS flags
ASFLAGS += -c -O0 -Wall -fmessage-length=0
ASFLAGS += $(ASFLAGS_PLATFORM)

# Set C source files.
C_SRC := $(wildcard ./src/*.c)

# Set C and Assembly source files.
ASM_SRC := \
	./src/startup.S

# Convert to object files
OBJS := $(C_SRC:.c=.o) $(ASM_SRC:.S=.o)

# Set the first rule in the file to 'make all'
.PHONY: all
all: main.elf

# Rules to build files.
%.o: %.S
	$(CC) -x assembler-with-cpp $(ASFLAGS) $< -o $@

%.o: %.c
	$(CC) -c $(CFLAGS) $< -o $@

main.elf: $(OBJS)
	$(CC) $(LDFLAGS) $^ -o $@

dump: main.elf
	$(OD) -D $<

format: main.elf
	esptool.py --chip esp32 elf2image --flash_mode=dio --flash_freq 40m --flash_size 4MB -o main.bin main.elf

flash: format
	esptool.py --chip esp32 --baud 460800 --before default_reset --after hard_reset write_flash -z --flash_mode dio --flash_freq 40m --flash_size 4MB 0x1000 main.bin

monitor:
	python -m serial.tools.miniterm /dev/ttyUSB0 115200

erase:
	esptool.py erase_flash
# Target to clean build artifacts.
.PHONY: clean
clean:
	rm -f $(OBJS)
	rm -f ./main.bin
	rm -f ./main.elf ./main.elf.map